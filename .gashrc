(define-shorthand "ls" "ls --color")
		  
(define (fmt string . args)
  (format #f string args))

(set! scheme-switch #\ยง)

(define-history-rule (lambda (txt) #t))

(define-builtin "cd.."
  (lambda (lst)
    (chdir "..")
    (cdr lst)))

(define ($ string)
  "splices in the resut of running string and collecting its output. We assume
string is a viable shell command. "
  (let* ((port (open-input-pipe string))
  	 (strs (get-string-all port)))
    (close-port port)
    strs))

(define (./ command . args)
  "command is a command, optionally with formatters contained therin, which gets
run through ./ via the shell. This is a little ./ mechanism to run something within an sexp. "
  (if (null? args)
      (system (string-append "./" command))
      (system (string-append "./" (apply format `(#f ,command ,@args))))))

;; (define-macro (./ . command-and-args)
;;   "command MUST be a single string, no spaces. args must be separated by spaces. 
;; some characters are illegal... look at the reference for more info ;; (needs to
;; be filled out). "
;;   (cond ((null? command-and-args)
;; 	 (echo "./ is a directory"))
;; 	(else
;; 	 (let ((cmd-and-args (map (lambda (el)
;; 				    (symbol->string el))
;; 				  command-and-args)))
;; 	   ()))))

(define (color-fmt color string . newline)
  (if (equal? (car newline) #f)
      (format #f "\\033[38;5;~Am~A\\033[0m" color string)
      (format #f "\\033[38;5;~Am~A\\033[0m\n" color string)))


  
    
  
